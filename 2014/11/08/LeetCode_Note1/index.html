<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  
  <title>LeetCode 笔记 1 in Java | 神经咩的生活哲学</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
    <meta name="author" content="yangscar">
  
  
    <meta name="description" content="1 2分查找时，上界一般是开区间，这样取均值最后总会收敛到up-1。
2 数组问题边界一定要注意，看问题是否考虑完全。
3 开闭区间端点认真对待。
4 Arrays.asList(1,2,3,4) =&amp;gt; 变成一个Collection， 可以批量初始化。
5 List 避免重复可以先check list.contains(x) 也可以
12ArrayList&amp;lt;ArrayList&amp;lt;I">
  
  <meta name="description" content="1 2分查找时，上界一般是开区间，这样取均值最后总会收敛到up-1。
2 数组问题边界一定要注意，看问题是否考虑完全。
3 开闭区间端点认真对待。
4 Arrays.asList(1,2,3,4) =&gt; 变成一个Collection， 可以批量初始化。
5 List 避免重复可以先check list.contains(x) 也可以
12ArrayList&lt;ArrayList&lt;I">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 笔记 1 in Java">
<meta property="og:url" content="http://yangscar.me/2014/11/08/LeetCode_Note1/">
<meta property="og:site_name" content="神经咩的生活哲学">
<meta property="og:description" content="1 2分查找时，上界一般是开区间，这样取均值最后总会收敛到up-1。
2 数组问题边界一定要注意，看问题是否考虑完全。
3 开闭区间端点认真对待。
4 Arrays.asList(1,2,3,4) =&gt; 变成一个Collection， 可以批量初始化。
5 List 避免重复可以先check list.contains(x) 也可以
12ArrayList&lt;ArrayList&lt;I">
<meta property="og:image" content="http://yangscarpic.qiniudn.com/20141108LeetCode_Note1_1.jpg">
<meta property="og:image" content="http://yangscarpic.qiniudn.com/20141108LeetCode_Note1_2.jpg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode 笔记 1 in Java">
<meta name="twitter:description" content="1 2分查找时，上界一般是开区间，这样取均值最后总会收敛到up-1。
2 数组问题边界一定要注意，看问题是否考虑完全。
3 开闭区间端点认真对待。
4 Arrays.asList(1,2,3,4) =&gt; 变成一个Collection， 可以批量初始化。
5 List 避免重复可以先check list.contains(x) 也可以
12ArrayList&lt;ArrayList&lt;I">

  
    <link rel="alternate" href="/atom.xml" title="神经咩的生活哲学" type="application/atom+xml">
  
  
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>

<body>
  <div class="wrapper">
    <header id="header">
  <div class="title">
    <h1><a href="/">神经咩的生活哲学</a></h1>
    <p><a href="/">设计，技术，大脑</a></p>
  </div>
  <nav class="nav">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about">About</a></li>
      
      
        <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
  <div class="clearfix"></div>
</header>
    <div class="content"><article class="post">
  <header>
    
      <div class="icon"></div>
      <a href="/2014/11/08/LeetCode_Note1/">
  <time datetime="2014-11-08T05:39:56.000Z">
    11月 8 2014
  </time>
</a>
    
    
  
    <h1 class="title">LeetCode 笔记 1 in Java</h1>
  

  </header>
  
  <div class="entry">
    
      <p>1 2分查找时，上界一般是开区间，这样取均值最后总会收敛到up-1。</p>
<p>2 数组问题边界一定要注意，看问题是否考虑完全。</p>
<p>3 开闭区间端点认真对待。</p>
<p>4 <code>Arrays.asList(1,2,3,4)</code> =&gt; 变成一个Collection， 可以批量初始化。</p>
<p>5 List 避免重复可以先check <code>list.contains(x)</code> 也可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; newList = <span class="keyword">new</span> </div><div class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(<span class="keyword">new</span> HashSet&lt;ArrayList&lt;Integer&gt;&gt;(oldList);</div></pre></td></tr></table></figure>

<p>6 Bit operator: ~是非。 ^是xor。</p>
<p>7 char 是 primitive 类型，木有自己的方法。得<code>Character.isDigit(curr)</code><br><code>Character.isLetter(curr)</code>。</p>
<p>8 kmp 中 最后返回的 <code>i-j</code> 其实就是文字串跳出时的长度 - PatternString跳出的长度。 1) 成功匹配，那就是匹配的起始点。2)没找到，那么 <code>i - j &gt; n - m (i = n, j &lt; m)</code>。</p>
<p>9 kmp 中 匹配则 <code>i++ , j++, next[i] = j</code>  // 反应的是j前匹配情况和i前一致，所以这个i如果匹配失败的话则应该用j匹配。 然后根据 <code>A[i] 是否= A[j]</code> 判断是否 <code>next[i] = next[j]</code>。<br>如果不匹配呢？ <code>i不动，j=-1</code>，那么下一次一定能匹配了(<code>P[-1] = &#39;*&#39;</code>)。</p>
<p>10 ArrayDeque offerLast &amp; removeLast 做Stack用比较方便。</p>
<p>11 SearchARange 中 可以使用 find upperbound 以及 lowerbound,  结果是<code>[lower, upper)</code>。 注意区间开闭。 二分法的核心是: </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// upperbound</span></div><div class="line"><span class="keyword">if</span> (target &gt;= *mid)</div><div class="line">    first = ++mid; <span class="comment">//开区间 )</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    last = mid;</div><div class="line"><span class="comment">// lowerbound</span></div><div class="line"><span class="keyword">if</span> (target &gt; *mid)</div><div class="line">    first = ++mid; </div><div class="line"><span class="keyword">else</span> </div><div class="line">    last = mid; <span class="comment">//闭区间 [</span></div></pre></td></tr></table></figure>

<p>12  数组初始化 <code>new int[]{1,2,3,4}</code> 或者 <code>int[] rt = {1,2,3,4}</code></p>
<p>13   通常Array 或者 LinkedList =&gt; BST 都采用二分法，那么很重要的参数即是数列的长度。</p>
<p>14  字符串缓存通常使用<code>StringBuilder</code>, 配套方法有<code>append(), toString()</code>。</p>
<p>15  Subset II, </p>
<blockquote>
<p>If S = [1,2,2], a solution is:</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">  [<span class="number">2</span>],</div><div class="line">  [<span class="number">1</span>],</div><div class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],</div><div class="line">  [<span class="number">2</span>,<span class="number">2</span>],</div><div class="line">  [<span class="number">1</span>,<span class="number">2</span>],</div><div class="line">  []</div><div class="line">]</div></pre></td></tr></table></figure>

<p>采用增量法处理，每次在之前的每个set的基础上加一。特殊情况就是如果当前项与前一项相同，那么会重复前一项完成的添加。所以需要从前一项处理对象的后一项开始。其他情况依然从零开始，关键代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length; ++i){</div><div class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> && num[i] == num[i-<span class="number">1</span>])</div><div class="line">        start = last; <span class="comment">//last last</span></div><div class="line">        last = subsets.size();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; last; ++j){</div><div class="line">        List&lt;Integer&gt; subset = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(subsets.get(j));</div><div class="line">        subset.add(num[i]);</div><div class="line">        subsets.add(subset);</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="comment">// ...</span></div></pre></td></tr></table></figure>

<a id="more"></a>

<p>16  构造二叉树(Pre+In Order || Post + In Order)，递归的来看<code># 表示root</code>：<br><code>Pre-Order: #LL...LLRR...RR</code><br><code>In-Order: LL...LL#RR...RR</code><br><code>Post-Order: LL...LLRR...RR#</code><br>可以用HashMap 优化查找InOrder的过程。或者注意区间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> TreeNode <span class="title">build</span>(Map&lt;Integer, Integer&gt; inMap, </div><div class="line"><span class="keyword">int</span>[] postorder, <span class="keyword">int</span> inBegin, <span class="keyword">int</span> postLast, <span class="keyword">int</span> len){</div><div class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postLast]);</div><div class="line">    <span class="keyword">int</span> iRoot = inMap.get(root.val);</div><div class="line">    root.left = build(inMap, postorder, inBegin, </div><div class="line">    	postLast-(len-(iRoot-inBegin)) ,iRoot-inBegin);</div><div class="line">    root.right = build(inMap, postorder, iRoot+<span class="number">1</span>, </div><div class="line">    	postLast-<span class="number">1</span>, len -(iRoot-inBegin)-<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>17 pow(x,n)的递归解法。其实就是把指数分解成2进制。比如$n\ mod\ 2$ 的余数是$2^0$上的数,$n/2\ mod\ 2$的余数是$2^1$上的的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">power</span>(<span class="keyword">double</span> x, <span class="keyword">int</span> n){</div><div class="line">    <span class="keyword">double</span> res = <span class="number">1</span>;</div><div class="line">    <span class="keyword">double</span> times = x;</div><div class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>){</div><div class="line">        <span class="keyword">if</span> ((n & <span class="number">1</span>) == <span class="number">1</span>) res*=times;</div><div class="line">        times *=times;</div><div class="line">        n&gt;&gt;=<span class="number">1</span>;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>18 Valid BST。不仅要考虑局部有序，整体也得保证根左边所有的点都小于他。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span>(TreeNode root, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper){</div><div class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> root.val &gt; lower && root.val &lt; upper </div><div class="line">    && isValidBST(root.left, lower, root.val) </div><div class="line">    && isValidBST(root.right, root.val,upper);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>19 Insertion Sort List。注意到与一般的Insertion Sort不同，我们不能从当前点往前寻找需要交换的点。考虑到LinkedList的特殊性，我们只能每次从前往后寻找要交换的点。dummy.next 一开始是null。在过程中，如果dummy这个list都比p.val要小，那么pre会指向最后一个，pre.next = null。而如果中间出现比p.val大的情况，pre指向&lt;=p.val的最后一个，完成交换后整个dummyListy依然有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</div><div class="line">ListNode p = head;</div><div class="line"><span class="keyword">while</span>(p!=<span class="keyword">null</span>){</div><div class="line">     ListNode pre = dummy;</div><div class="line">     <span class="keyword">while</span>(pre.next!=<span class="keyword">null</span>){</div><div class="line">        <span class="keyword">if</span> (pre.next.val &lt;= p.val)</div><div class="line">            pre = pre.next;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</div><div class="line">    }</div><div class="line">            </div><div class="line">    ListNode tmp = p.next;</div><div class="line">    p.next = pre.next;</div><div class="line">    pre.next = p;</div><div class="line">    p = tmp;</div><div class="line">            </div><div class="line">}</div><div class="line">        </div><div class="line"><span class="keyword">return</span> dummy.next;</div></pre></td></tr></table></figure>

<p>20 Edit Distance: 要求求两个String 之间的距离。每一步可以改变一个字符，添加一个字符或者删除一个字符。于是我们可以建立一个表，其中f[i][j]表示A.sub(0,i) 到B.sub(0,j)的最小Edit Distance。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>] <span class="comment">//当A[i-1]=B[j-1]</span></div><div class="line">f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span> <span class="comment">//Replace</span></div><div class="line">f[i][j] = f[i][j-<span class="number">1</span>]+<span class="number">1</span> <span class="comment">// add in A</span></div><div class="line">f[i][j] = f[i-<span class="number">1</span>][j]+<span class="number">1</span> <span class="comment">// delete in A, add in B.</span></div></pre></td></tr></table></figure>

<p>21 Permutation II. 采用组合数学中学到的字典序生成法。nextPermutation 算法如下，结束时，i=0，所有对都逆序了。</p>
<p>$$<br>1)\ i=max{j|p<em>{j-1}&lt;p_j} \<br>2)\ h=max{k|p</em>{i-1}&lt;p<em>k} \<br>3)\ swap(num,p</em>{i-1},p_k) \<br>4)\ reverse(num,i,end)<br>$$</p>
<p>22 Recover BST, 一个简单的作法是先将InOrder遍历结果存入一个List中，从左到右寻找第一个$a[i]&gt;a[i+1]$,从右到左寻找第一个$a[j-1]&gt;a[j]$。然后交换两个TreeNode的val。</p>
<p>23 关于PostOrderTraversal。一直往左，不断入栈这个没有问题。然后取栈顶，先看能不能往左，然后如果有右得先往右，如果没有右则可以处理当前栈顶节点。(这里可能还有右但是右孩子已经被处理完了，所以需要有一个额外的last指针指向上一个被处理的节点，如果需要处理的节点的右孩子==last，那么该节点也可以被处理了)</p>
<p>24 Distinct SubSequences<br><img src="http://yangscarpic.qiniudn.com/20141108LeetCode_Note1_1.jpg" alt="Alt text"><br>f[i,j] 表示T[0,j]在S[0,i]中出现的次数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f[<span class="link_label">i,j</span>] = f[<span class="link_label">i-1</span>][<span class="link_reference">j</span>]// when T[j]!=S[i], 不用S[i]</div><div class="line">f[<span class="link_label">i,j</span>] = f[<span class="link_label">i-1</span>][<span class="link_reference">j</span>] + f[<span class="link_label">i-1</span>][<span class="link_reference">j-1</span>]// when T[j]==S[i], 可以用或不用S[i]</div></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span>(String S, String T) {</div><div class="line">    <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[T.length()+<span class="number">1</span>];</div><div class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= S.length(); ++i){</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = T.length(); j &gt; <span class="number">0</span>; --j ){</div><div class="line">            f[j] += S.charAt(i-<span class="number">1</span>)==T.charAt(j-<span class="number">1</span>)? f[j-<span class="number">1</span>]:<span class="number">0</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> f[T.length()];</div><div class="line">}</div></pre></td></tr></table></figure>

<p>24 Jump Game I. 这个比较简单，我们可以一步步更新MaxReach = max(maxReach, i+A[i])。同时保证每次i&lt;=reach即可。</p>
<p>25 Jump Game II. 我们需要借助last记住上一步的maxReach，cur记录的是上一格的maxReach。当i &gt; last 的时候，上一步一个不能cover当前位置，所以需要多一步:++step。但是如果cur &lt;= last 的话，我多一步也无法到达更远的地方，所以只能返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span>(<span class="keyword">int</span>[] A) {</div><div class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last = <span class="number">0</span>; </div><div class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; ++i){</div><div class="line">        <span class="keyword">if</span> (i &gt; last){</div><div class="line">            <span class="keyword">if</span> (cur &lt;= last)</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            last = cur;</div><div class="line">            step++;</div><div class="line">                </div><div class="line">        }</div><div class="line">        cur = Math.max(cur, i+A[i]);</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> step;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>26 Anagrams. 利用HashMap即可，把字符串先排序作为key，把字符串本身作为Value中List的一员插入。<br>需要注意 charArray不能直接toString(), 可以使用 new String(charArray);</p>
<p>27 Clone Graph. 可以利用HashMap建立旧新节点的一一映射关系，如果新节点尚未被创建，那么可以递归地在该处创建一个图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> UndirectedGraphNode <span class="title">cloneGraph</span>(UndirectedGraphNode node, </div><div class="line">        HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map){</div><div class="line">    UndirectedGraphNode newNode = <span class="keyword">new</span> UndirectedGraphNode(node.label);</div><div class="line">    map.put(node, newNode);</div><div class="line">    <span class="keyword">for</span> (UndirectedGraphNode neighbor: node.neighbors){</div><div class="line">        UndirectedGraphNode newNeighbor = map.get(neighbor);</div><div class="line">        <span class="keyword">if</span> (newNeighbor == <span class="keyword">null</span>)</div><div class="line">            newNeighbor = cloneGraph(neighbor, map);</div><div class="line">            newNode.neighbors.add(newNeighbor);</div><div class="line">                </div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> newNode;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>28 Scramble String. 可以递归的考虑这个问题。把字符串分为k 和 n-k 两段。<br>设状态 <code>f[n][i][j]</code> 表示长度为n，起点为<code>s1[i]</code>的子串与起点为<code>s2[j]</code>的两个子串是否互为scramble。状态转移方程为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">f[n][i][j] = (f[k][i][j] && f[n-k][i+k][j+k]) ||</div><div class="line">            (f[k][i][j+k] && f[n-k][i+k][j]);</div><div class="line">*/</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; N; ++i)</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt;N; ++j)</div><div class="line">        f[<span class="number">1</span>][i][j] = s1.charAt(i) == s2.charAt(j);</div><div class="line">        </div><div class="line">        </div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;=N; ++n ){</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i+n &lt;=N; ++i){</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j+n &lt;=N; ++j){</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">1</span>; k&lt; n; ++k){</div><div class="line">                <span class="keyword">if</span> ((f[k][i][j] && f[n-k][i+k][j+k]) ||</div><div class="line">                    (f[k][i][j+n-k] && f[n-k][i+k][j])){</div><div class="line">                        f[n][i][j] = <span class="keyword">true</span>;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">return</span> f[N][<span class="number">0</span>][<span class="number">0</span>];</div></pre></td></tr></table></figure>

<p>29 First Missing Positive。使用桶排序。桶排序的核心是直接把数换到它应该在的位置。然后再找哪个地方漏了。</p>
<p>30 Merge K Sorted Lists 直接两两合并会超时。其实最直观的想法是每次从k个List的头部选取最小的添加到结果中，所以可以借助优先级队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> ListNode <span class="title">mergeKLists</span>(List&lt;ListNode&gt; lists) {</div><div class="line">        PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;ListNode&gt;(<span class="number">10</span>,</div><div class="line">        <span class="keyword">new</span> Comparator&lt;ListNode&gt;(){</div><div class="line">        <span class="annotation">@Override</span></div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(ListNode a, ListNode b){</div><div class="line">            <span class="keyword">return</span> a.val - b.val;</div><div class="line">        }</div><div class="line">    });</div><div class="line">        </div><div class="line">    <span class="keyword">for</span> (ListNode node: lists){</div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</div><div class="line">            heap.add(node);</div><div class="line">    }</div><div class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</div><div class="line">    ListNode pre = dummy;</div><div class="line">    <span class="keyword">while</span>(!heap.isEmpty()){</div><div class="line">        ListNode top = heap.poll();</div><div class="line">        pre.next = top;</div><div class="line">        <span class="keyword">if</span> (top.next != <span class="keyword">null</span>)</div><div class="line">            heap.add(top.next);</div><div class="line">                </div><div class="line">        pre = pre.next;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> dummy.next;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>31 Maximum Rectangle。</p>
<p>首先我们把问题缩小到一行来看。用L[n],R[n],H[n]储存当前位置的左右端点和包括本行在内的最高高度。先从左往右扫，确定左端点。’1’: H[j]=1，左界取Max(left, 0/<em>初始L</em>/)。’0’：那么下一个1的左界至少是j+1，用left储存。</p>
<p>下面我们看i+1行。 ‘1’: H[j]++，左界取Max(left, L[j]/<em>上一行的L</em>/)。’0’：那么下一个1的左界至少是j+1，用left储存。同时H[j]=0，L[j] =0, R[j] =n。也就是下一行的此列与之前行此列的结果无关。</p>
<p>接下来我们从右往左扫，确定R[j]。’1’: 右界取Min(right, R[j])。此时L R H 都以确定，可以求得迄今为止包括此行此列能求得的最大的矩形大小。’0’：那么下一个1的右界至多是j。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span>(<span class="keyword">char</span>[][] matrix) {</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> m = matrix.length;</div><div class="line">        <span class="keyword">if</span> (m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] L, R, H;</div><div class="line">        L = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        R = <span class="keyword">new</span> <span class="keyword">int</span>[n]; Arrays.fill(R,n);</div><div class="line">        H = <span class="keyword">new</span> <span class="keyword">int</span>[n];</div><div class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i){</div><div class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = n;</div><div class="line">            <span class="comment">//from left to right</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j){</div><div class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>){</div><div class="line">                    H[j]++;</div><div class="line">                    L[j] = Math.max(L[j], left);</div><div class="line">                }<span class="keyword">else</span>{</div><div class="line">                    left = j+<span class="number">1</span>;</div><div class="line">                    H[j]=<span class="number">0</span>;</div><div class="line">                    L[j]=<span class="number">0</span>;</div><div class="line">                    R[j]=n;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="comment">//from right to left</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n-<span class="number">1</span>; j&gt;=<span class="number">0</span>; --j){</div><div class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>){</div><div class="line">                    R[j] = Math.min(R[j], right);</div><div class="line">                    ret = Math.max(ret, (R[j]-L[j])*H[j]);</div><div class="line">                }<span class="keyword">else</span>{</div><div class="line">                    right = j;</div><div class="line">                }</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>32 Sort List. 链表类型题目中，采用快慢两个指针是很常见的手法。可以1)把链表分成两段，2)找环路。</p>
<p>33 Best time to sell and buy stock 系列。<br>1)只能买一次卖一次。用一个变量存迄今为止的最小值，然后不停的试着去卖。<br>2)可以买卖无数次。把查分序列大于0的都加起来即可。<br>3)只能买卖2次。也就是分成两段，前一段买卖一次后一段买卖一次。直接这样算的话是$O(n^2)$。所以考虑先把从左至右得到的当前点最大profit存起来，然后从右往左，根据迄今为止最大的卖出价，不停试着买。看怎么样前后两轮交易获益最大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//3)</span></div><div class="line"> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span>(<span class="keyword">int</span>[] prices) {</div><div class="line">        <span class="keyword">if</span> (prices.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span>[] profit = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</div><div class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt; prices.length; ++i){</div><div class="line">            profit[i] = Math.max(profit[i-<span class="number">1</span>], prices[i]-minPrice);</div><div class="line">            minPrice = Math.min(minPrice, prices[i]);</div><div class="line">        }</div><div class="line">        <span class="keyword">int</span> maxPrice = prices[prices.length-<span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> maxProfit = profit[prices.length-<span class="number">1</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=prices.length-<span class="number">2</span>; i&gt;<span class="number">0</span>;--i){</div><div class="line">            maxProfit = Math.max(maxProfit, profit[i-<span class="number">1</span>]+maxPrice-prices[i]);</div><div class="line">            maxPrice = Math.max(maxPrice, prices[i]);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> maxProfit;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>34 Largest Rectangle in Histogram. 这个神奇的题目需要借助一个栈。让我们来考虑从左至右加入bar。当bar的高度不是递增时，出现情况1，就是加入一个更矮的bar显然会使得矩形面积减小，所以先pop对前面的bar进行处理。而pop到情况2是，也就是a比b(当前位置)更矮，那我们就停止pop，转而将b push进去。</p>
<p><img src="http://yangscarpic.qiniudn.com/20141108LeetCode_Note1_2.jpg" alt="Alt text"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span>(<span class="keyword">int</span>[] height) {</div><div class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</div><div class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</div><div class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; height.length){</div><div class="line">            <span class="keyword">if</span> (q.isEmpty() || height[q.peekLast()] &lt;= height[i])</div><div class="line">                q.offerLast(i++);</div><div class="line">            <span class="keyword">else</span>{</div><div class="line">                <span class="keyword">int</span> pos = q.removeLast();</div><div class="line">                maxArea = Math.max(maxArea, </div><div class="line">                    (q.isEmpty()? i : i-q.peekLast()-<span class="number">1</span>)*height[pos]);</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">while</span>(!q.isEmpty()){</div><div class="line">            <span class="keyword">int</span> pos = q.removeLast();</div><div class="line">            maxArea = Math.max(maxArea, </div><div class="line">                    (q.isEmpty()? i : i-q.peekLast()-<span class="number">1</span>)*height[pos]);</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> maxArea;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>35 Word Break。首先我们递归的思考，假设f[i] 表示字符串s[0,i]可分。那么$f[j] = \exists j,s.t. f[j]\ and\ s[j,i] \in dict == true$。那么其实我们也可以用动态规划来做。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span>(String s, Set&lt;String&gt; dict) {</div><div class="line">        <span class="keyword">int</span> n = s.length();</div><div class="line">        <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</div><div class="line">        f[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i )</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i-<span class="number">1</span>; j &gt;=<span class="number">0</span>; --j){</div><div class="line">                <span class="keyword">if</span> (f[j] && dict.contains(s.substring(j,i)))</div><div class="line">                    f[i] = <span class="keyword">true</span>;</div><div class="line">            }</div><div class="line">        <span class="keyword">return</span> f[n];</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>36 Word Break II. 这题需要返回结果，so我们先记录s[0,i]中可以cut之后，[j,i)也是一个词是j是哪些。然后深度优先进行搜索。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span>(String s, Set&lt;String&gt; dict) {</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n = s.length();</div><div class="line">    <span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</div><div class="line">    <span class="keyword">boolean</span>[][] cut = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n+<span class="number">1</span>];</div><div class="line">    f[<span class="number">0</span>] = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; ++i)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i-<span class="number">1</span>; j&gt;=<span class="number">0</span>; --j)</div><div class="line">            <span class="keyword">if</span> (f[j] && dict.contains(s.substring(j,i))){</div><div class="line">                f[i] = <span class="keyword">true</span>;</div><div class="line">                cut[j][i] = <span class="keyword">true</span>;<span class="comment">// [j,i) is a feasible word.</span></div><div class="line">            }</div><div class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    Deque&lt;String&gt; path = <span class="keyword">new</span> ArrayDeque&lt;String&gt;();</div><div class="line">    dfs(s, cut, s.length(), path, res);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">    </div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(String s, <span class="keyword">boolean</span>[][] cut, </div><div class="line">	<span class="keyword">int</span> cur, Deque&lt;String&gt; path, List&lt;String&gt; res){</div><div class="line">    <span class="keyword">if</span>(cur == <span class="number">0</span>){</div><div class="line">        String tmp=<span class="string">""</span>;</div><div class="line">        <span class="keyword">for</span>(String str:path){</div><div class="line">            tmp += str + <span class="string">" "</span>;</div><div class="line">        }</div><div class="line">        tmp = tmp.substring(<span class="number">0</span>, tmp.length()-<span class="number">1</span>);</div><div class="line">        res.add(tmp);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=cur-<span class="number">1</span>; i &gt;=<span class="number">0</span>; --i){</div><div class="line">        <span class="keyword">if</span> (cut[i][cur]){</div><div class="line">            path.offerFirst(s.substring(i,cur));</div><div class="line">            dfs(s, cut, i, path, res);</div><div class="line">            path.removeFirst();</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>37 Merge Interval. 先排序，然后逐个比对并更新Interval，直到确定这个Interval.end &lt; 下个interval.start，于是加入result，别忘了最后一个。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Collections.sort(list, <span class="keyword">new</span> Comparator(){</div><div class="line">    <span class="annotation">@Override</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span>(Interval a, Interval b){</div><div class="line">        <span class="keyword">if</span> (a.start == b.start)</div><div class="line">            <span class="keyword">return</span> a.end-b.end;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> a.start-b.start;</div><div class="line">    }</div><div class="line">});</div></pre></td></tr></table></figure>

<p>38 Insert Interval. Maybe you can use binarySearch. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// in a for loop</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">new</span>.start &gt; cur.end) ++i;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>.end &lt; cur.start) {</div><div class="line">    intervals.add(i,<span class="keyword">new</span>);</div><div class="line">    <span class="keyword">return</span> intervals;</div><div class="line">    }</div><div class="line"><span class="keyword">else</span> {</div><div class="line">    <span class="keyword">new</span>.start = min(<span class="keyword">new</span>.start, cur.start);</div><div class="line">    <span class="keyword">new</span>.end = min(<span class="keyword">new</span>.end, cur.end);</div><div class="line">    intervals.remove(i);</div><div class="line">    --i;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>39 Binary Tree Maximum Path Sum. Use dfs, return max(left, right). when calculate the sum, add left + right(when &gt; 0) + root.val.</p>
<p>40 Multiply String. 记住乘法的乘数每位有个offset。最后toString的时候注意细节。</p>
<p>41 Spiral Matrix. !Not always square!</p>
<p>42 InterLeaving String.<br><code>f[i][j]</code> stands for that s1[0,i) s2[0,j) has interleaving matched s3[0,i+j).</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f[<span class="link_label">i</span>][<span class="link_reference">j</span>] = f[<span class="link_label">i-1</span>][<span class="link_reference">j</span>] && s3[i+j-1]==s1[i-1] </div><div class="line"><span class="code">        ||f[i][j-1] && s3[i+j-1]==s2[j-1]</span></div></pre></td></tr></table></figure>

<p>也可用滚动数组做，注意边界条件<code>f[0]</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span>[] f = <span class="keyword">new</span> <span class="keyword">boolean</span>[s2.length()+<span class="number">1</span>];</div><div class="line">f[<span class="number">0</span>]= <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=s2.length(); ++i)</div><div class="line">    f[i] = f[i-<span class="number">1</span>] && s2.charAt(i-<span class="number">1</span>) == s3.charAt(i-<span class="number">1</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=s1.length(); ++i){</div><div class="line">    f[<span class="number">0</span>] = f[<span class="number">0</span>] && s1.charAt(i-<span class="number">1</span>) == s3.charAt(i-<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=s2.length();++j)</div><div class="line">        f[j] = (s1.charAt(i-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>) && f[j]) </div><div class="line">            || (s2.charAt(j-<span class="number">1</span>)==s3.charAt(i+j-<span class="number">1</span>) && f[j-<span class="number">1</span>]);</div><div class="line">}</div><div class="line"><span class="keyword">return</span> f[s2.length()];</div></pre></td></tr></table></figure>

<p>43 Palindrome Partitioning II. 得借助备忘录<code>isPalindrome[i][j]</code>表示<code>s[i,j]</code>是否是palindrome。用<code>cuts[i]</code>记录i位置前最少有多少个cut。每次更新cuts=min(回文串前一个cuts+1和当前cuts)，注意当回文串前没字符时cuts始终为0.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCut</span>(String s) {</div><div class="line">        <span class="keyword">if</span> (s.isEmpty()) {</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">boolean</span>[][] isPalindrome = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</div><div class="line">        <span class="keyword">int</span>[] cuts = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) </div><div class="line">            cuts[i] = i;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) {</div><div class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)</div><div class="line">                        && (i - j &lt; <span class="number">2</span> || isPalindrome[j + <span class="number">1</span>][i - <span class="number">1</span>])) {</div><div class="line">                    isPalindrome[j][i] = <span class="keyword">true</span>;</div><div class="line">                    cuts[i] = j-<span class="number">1</span>&gt;=<span class="number">0</span>?Math.min(cuts[i], cuts[j-<span class="number">1</span>]+<span class="number">1</span>):<span class="number">0</span>;</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> cuts[s.length()-<span class="number">1</span>];</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>44 Minimum Window Substring. 用双指针维护一个区间。先尾指针往后扫，直到有一个窗口包含所有T的字符后，考虑收缩头指针。这样所有的情况都不会遗漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> String <span class="title">minWindow</span>(String S, String T) {</div><div class="line">        <span class="keyword">if</span> (S.isEmpty() || S.length() &lt; T.length()) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> ASCII_MAX=<span class="number">256</span>;</div><div class="line">        <span class="keyword">int</span>[] appeared_count = <span class="keyword">new</span> <span class="keyword">int</span>[ASCII_MAX];</div><div class="line">        <span class="keyword">int</span>[] expected_count = <span class="keyword">new</span> <span class="keyword">int</span>[ASCII_MAX];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: T.toCharArray()) expected_count[c]++;</div><div class="line">        <span class="keyword">int</span> min_end = Integer.MAX_VALUE-<span class="number">1</span>, min_start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> appeared_c = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = <span class="number">0</span>; end&lt;S.length(); ++end){</div><div class="line">            <span class="keyword">if</span> (expected_count[S.charAt(end)]&gt;<span class="number">0</span>){</div><div class="line">                appeared_count[S.charAt(end)]++;</div><div class="line">                <span class="keyword">if</span> (appeared_count[S.charAt(end)] &lt;= expected_count[S.charAt(end)]) </div><div class="line">                	appeared_c++;</div><div class="line">            }</div><div class="line">            <span class="keyword">if</span> (appeared_c == T.length()){</div><div class="line">                <span class="keyword">while</span>(expected_count[S.charAt(start)]==<span class="number">0</span> ||</div><div class="line">                      appeared_count[S.charAt(start)] &gt; expected_count[S.charAt(start)]){</div><div class="line">                      appeared_count[S.charAt(start)]--;</div><div class="line">                      start++;</div><div class="line">                }</div><div class="line">                <span class="keyword">if</span> (end-start+<span class="number">1</span> &lt; min_end-min_start+<span class="number">1</span>){</div><div class="line">                    min_start = start;</div><div class="line">                    min_end = end;</div><div class="line">                }    </div><div class="line">            }</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> min_end&gt;S.length()? <span class="string">""</span>:S.substring(min_start, min_end+<span class="number">1</span>);</div><div class="line">        </div><div class="line">    }</div></pre></td></tr></table></figure>

<p>45 Decode Ways. 类似斐波拉契数列。</p>
<p>46 Maximum Product Subarray. 关键是一个很小的负数可能*一个负数会变成很大的正数哦！所有可以用max[i] 和 min[i]两个数组记录迄今为止的最大和最小值。</p>
<p>47 Divide Two Integer. 边界情况有除0，Integer.MIN_VALUE 的overflow。先判断正负，后面所有运算均用正值。将除数翻倍加速运算。</p>
<blockquote>
<p>首先一直double除数到&lt;=被除数的最大值。<br>if dividend&gt;= divisor, dividend -=divisor, ans++<br>in the next run, ans &lt;&lt;=1</p>
</blockquote>
<p>48 Surrounded Regions. bfs。可以借助队列or栈把情况放入。从四面墙往中间走，遇到O则继续，遇到X则停止。</p>
<p>49 Wildcard Matching. remember the location of <code>*</code> 。<br>50 Valid Number. 这道题可以用有限状态机解。用到了enum. PA(How to):<code>Input.SPACE.ordinal() = 1</code> and the enum type cannot be local. &gt;_&gt; .</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Input{</div><div class="line">            INVALID,    <span class="comment">//0</span></div><div class="line">            SPACE,      <span class="comment">//1</span></div><div class="line">            SIGN,       <span class="comment">//2</span></div><div class="line">            DIGIT,      <span class="comment">//3</span></div><div class="line">            DOT,        <span class="comment">//4</span></div><div class="line">            EXPONENT,   <span class="comment">//5</span></div><div class="line">            NUM_INPUTS  <span class="comment">//6</span></div><div class="line">        }</div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span>(String s) {</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[][] next = {</div><div class="line">            {-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>},     <span class="comment">//0 Nothing</span></div><div class="line">            {-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, -<span class="number">1</span>},   <span class="comment">//1 -()</span></div><div class="line">            {-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">1</span>, -<span class="number">1</span>},  <span class="comment">//2 -.()</span></div><div class="line">            {-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>},    <span class="comment">//3 -9()</span></div><div class="line">            {-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>},   <span class="comment">//4 -9.5E()</span></div><div class="line">            {-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">7</span>,-<span class="number">1</span>, -<span class="number">1</span>},   <span class="comment">//5 -9.5E-() </span></div><div class="line">            {-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">1</span>, <span class="number">4</span>},   <span class="comment">//6 -.9()</span></div><div class="line">            {-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>},  <span class="comment">//7 -9.5e-9</span></div><div class="line">            {-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">6</span>, -<span class="number">1</span>, <span class="number">4</span>}    <span class="comment">//8 -9.</span></div><div class="line">        };</div><div class="line">        s = s.trim();</div><div class="line">        <span class="keyword">int</span> state = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length(); ++i){</div><div class="line">            Input input = Input.INVALID;</div><div class="line">            <span class="keyword">char</span> ch = s.charAt(i);</div><div class="line">            <span class="keyword">if</span> (Character.isSpace(ch))</div><div class="line">                input = Input.SPACE;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(ch))</div><div class="line">                input = Input.DIGIT;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">'.'</span>)</div><div class="line">                input = Input.DOT;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">'E'</span> || ch ==<span class="string">'e'</span>)</div><div class="line">                input = Input.EXPONENT;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ch ==<span class="string">'+'</span> || ch == <span class="string">'-'</span>)</div><div class="line">                input = Input.SIGN;</div><div class="line">            </div><div class="line">            state = next[state][input.ordinal()];</div><div class="line">            <span class="keyword">if</span> (state == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> state == <span class="number">3</span> || state == <span class="number">6</span> || state == <span class="number">7</span> || state ==<span class="number">8</span>;</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>51 WordLadder II. 这题有点难，需要输出所有可能。 BFS, we need record the states layer by layer.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title">findLadders</span>(String start, String end, </div><div class="line">    Set&lt;String&gt; dict) {</div><div class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (start.equals(end)){</div><div class="line">            List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">            l.add(start);</div><div class="line">            ans.add(l);</div><div class="line">            <span class="keyword">return</span> ans;</div><div class="line">        }</div><div class="line">        </div><div class="line">        Set&lt;String&gt; current = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        Set&lt;String&gt; next = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        Map&lt;String, List&lt;String&gt;&gt; father = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</div><div class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</div><div class="line">        </div><div class="line">        current.add(start);</div><div class="line">        <span class="keyword">while</span>(!current.isEmpty() && !found){</div><div class="line">            <span class="keyword">for</span> (String word: current)</div><div class="line">                visited.add(word);</div><div class="line">            <span class="keyword">for</span> (String word: current){</div><div class="line">                Set&lt;String&gt; new_states = extend(word, visited, dict, end);</div><div class="line">                <span class="keyword">for</span> (String state: new_states){</div><div class="line">                    <span class="keyword">if</span> (state.equals(end)) found = <span class="keyword">true</span>;</div><div class="line">                    next.add(state);</div><div class="line">                    <span class="keyword">if</span> (!father.containsKey(state))</div><div class="line">                        father.put(state, <span class="keyword">new</span> ArrayList());</div><div class="line">                    father.get(state).add(word);</div><div class="line">                }</div><div class="line">            }</div><div class="line">            current.clear();</div><div class="line">            Set&lt;String&gt; tmpSet = current;</div><div class="line">            current = next;</div><div class="line">            next = tmpSet;</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (found){</div><div class="line">            Deque&lt;String&gt; path = <span class="keyword">new</span> ArrayDeque&lt;String&gt;();</div><div class="line">            generatePath(father, path, start, end, ans);</div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> ans;</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generatePath</span>(Map&lt;String, List&lt;String&gt;&gt; father,</div><div class="line">        Deque&lt;String&gt; path, <span class="keyword">final</span> String start, <span class="keyword">final</span> String word,</div><div class="line">        List&lt;List&lt;String&gt;&gt; ans){</div><div class="line">        path.offerLast(word);</div><div class="line">        <span class="keyword">if</span> (word.equals(start)){</div><div class="line">            ArrayList&lt;String&gt; toAdd = <span class="keyword">new</span> ArrayList&lt;String&gt;(path);</div><div class="line">            Collections.reverse(toAdd);</div><div class="line">            ans.add(toAdd);</div><div class="line">        } <span class="keyword">else</span> {</div><div class="line">            <span class="keyword">for</span> (String f: father.get(word))</div><div class="line">                generatePath(father, path, start, f, ans);</div><div class="line">        }</div><div class="line">        path.removeLast();</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> Set&lt;String&gt; <span class="title">extend</span>(String s, Set&lt;String&gt; visited, </div><div class="line">    	Set&lt;String&gt; dict, String end){</div><div class="line">        Set&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i){</div><div class="line">            <span class="keyword">char</span> old_char =<span class="string">' '</span>;</div><div class="line">            <span class="keyword">char</span>[] new_word = s.toCharArray();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c&lt;=<span class="string">'z'</span>; ++c){</div><div class="line">                <span class="keyword">if</span> (c == new_word[i]) <span class="keyword">continue</span>;</div><div class="line">                old_char = new_word[i];</div><div class="line">                new_word[i] =c;</div><div class="line">                String new_str = <span class="keyword">new</span> String(new_word);</div><div class="line">                <span class="keyword">if</span> ((dict.contains(new_str) || new_str.equals(end))</div><div class="line">                    && !visited.contains(new_str))</div><div class="line">                    result.add(new_str);</div><div class="line">                new_word[i] = old_char;</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>52 利用Map<double, integer=""> 记录以每个点为原点，斜率相同的点的个数。注意Double的边界情况，比如0, Double.MAX_VALUE。</double,></p>

    
  </div>
  <footer>
    
      
  <div class="categories">
    <a class="categories-link" href="/categories/Tech/">Tech</a>
  </div>

      
  <div class="tags">
    <a class="tags-link" href="/tags/Algorithms/">Algorithms</a>
  </div>

    
    <div class="clearfix"></div>
  </footer>
</article>


<section id="comment">
  <h1 class="title">评论</h1>
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</div>
  </div>
  <footer id="footer"><div class="copyright">
  
  &copy; 2016 <a href="/">yangscar</a>
  
</div>
<div class="theme-copyright">
  Theme by <a href="https://github.com/orderedlist" target="_blank">orderedlist</a>
   | 
  Redesign by <a href="http://heroicyang.com/" target="_blank">Heroic Yang</a>
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
<script src="/js/scale.fix.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
  var disqus_shortname = 'yangscarme';

  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  }());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
</script>

</body>
</html>